{"ast":null,"code":"import _asyncToGenerator from \"/Users/arifshaikh/Documents/GitHub/ld-demo-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction e(e) {\n  function t(e, t) {\n    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.message = e, this.code = t;\n  }\n  return t.prototype = new Error(), t.prototype.name = e, t.prototype.constructor = t, t;\n}\nconst t = e(\"LaunchDarklyUnexpectedResponseError\"),\n  n = e(\"LaunchDarklyInvalidEnvironmentIdError\"),\n  r = e(\"LaunchDarklyInvalidUserError\"),\n  o = e(\"LaunchDarklyInvalidEventKeyError\"),\n  i = e(\"LaunchDarklyInvalidArgumentError\"),\n  a = e(\"LaunchDarklyFlagFetchError\");\nfor (var s = {\n    LDUnexpectedResponseError: t,\n    LDInvalidEnvironmentIdError: n,\n    LDInvalidUserError: r,\n    LDInvalidEventKeyError: o,\n    LDInvalidArgumentError: i,\n    LDInvalidDataError: e(\"LaunchDarklyInvalidDataError\"),\n    LDFlagFetchError: a,\n    LDTimeoutError: e(\"LaunchDarklyTimeoutError\"),\n    isHttpErrorRecoverable: function (e) {\n      return !(e >= 400 && e < 500) || 400 === e || 408 === e || 429 === e;\n    }\n  }, c = function (e) {\n    var t = m(e),\n      n = t[0],\n      r = t[1];\n    return 3 * (n + r) / 4 - r;\n  }, u = function (e) {\n    var t,\n      n,\n      r = m(e),\n      o = r[0],\n      i = r[1],\n      a = new g(function (e, t, n) {\n        return 3 * (t + n) / 4 - n;\n      }(0, o, i)),\n      s = 0,\n      c = i > 0 ? o - 4 : o;\n    for (n = 0; n < c; n += 4) t = f[e.charCodeAt(n)] << 18 | f[e.charCodeAt(n + 1)] << 12 | f[e.charCodeAt(n + 2)] << 6 | f[e.charCodeAt(n + 3)], a[s++] = t >> 16 & 255, a[s++] = t >> 8 & 255, a[s++] = 255 & t;\n    2 === i && (t = f[e.charCodeAt(n)] << 2 | f[e.charCodeAt(n + 1)] >> 4, a[s++] = 255 & t);\n    1 === i && (t = f[e.charCodeAt(n)] << 10 | f[e.charCodeAt(n + 1)] << 4 | f[e.charCodeAt(n + 2)] >> 2, a[s++] = t >> 8 & 255, a[s++] = 255 & t);\n    return a;\n  }, l = function (e) {\n    for (var t, n = e.length, r = n % 3, o = [], i = 16383, a = 0, s = n - r; a < s; a += i) o.push(y(e, a, a + i > s ? s : a + i));\n    1 === r ? (t = e[n - 1], o.push(d[t >> 2] + d[t << 4 & 63] + \"==\")) : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], o.push(d[t >> 10] + d[t >> 4 & 63] + d[t << 2 & 63] + \"=\"));\n    return o.join(\"\");\n  }, d = [], f = [], g = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, v = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", p = 0; p < 64; ++p) d[p] = v[p], f[v.charCodeAt(p)] = p;\nfunction m(e) {\n  var t = e.length;\n  if (t % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n  var n = e.indexOf(\"=\");\n  return -1 === n && (n = t), [n, n === t ? 0 : 4 - n % 4];\n}\nfunction h(e) {\n  return d[e >> 18 & 63] + d[e >> 12 & 63] + d[e >> 6 & 63] + d[63 & e];\n}\nfunction y(e, t, n) {\n  for (var r, o = [], i = t; i < n; i += 3) r = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (255 & e[i + 2]), o.push(h(r));\n  return o.join(\"\");\n}\nf[\"-\".charCodeAt(0)] = 62, f[\"_\".charCodeAt(0)] = 63;\nvar w = {\n    byteLength: c,\n    toByteArray: u,\n    fromByteArray: l\n  },\n  b = Array.isArray,\n  k = Object.keys,\n  E = Object.prototype.hasOwnProperty,\n  D = function e(t, n) {\n    if (t === n) return !0;\n    if (t && n && \"object\" == typeof t && \"object\" == typeof n) {\n      var r,\n        o,\n        i,\n        a = b(t),\n        s = b(n);\n      if (a && s) {\n        if ((o = t.length) != n.length) return !1;\n        for (r = o; 0 !== r--;) if (!e(t[r], n[r])) return !1;\n        return !0;\n      }\n      if (a != s) return !1;\n      var c = t instanceof Date,\n        u = n instanceof Date;\n      if (c != u) return !1;\n      if (c && u) return t.getTime() == n.getTime();\n      var l = t instanceof RegExp,\n        d = n instanceof RegExp;\n      if (l != d) return !1;\n      if (l && d) return t.toString() == n.toString();\n      var f = k(t);\n      if ((o = f.length) !== k(n).length) return !1;\n      for (r = o; 0 !== r--;) if (!E.call(n, f[r])) return !1;\n      for (r = o; 0 !== r--;) if (!e(t[i = f[r]], n[i])) return !1;\n      return !0;\n    }\n    return t != t && n != n;\n  };\nconst x = [\"key\", \"ip\", \"country\", \"email\", \"firstName\", \"lastName\", \"avatar\", \"name\"];\nfunction O(e) {\n  const t = unescape(encodeURIComponent(e));\n  return w.fromByteArray(function (e) {\n    const t = [];\n    for (let n = 0; n < e.length; n++) t.push(e.charCodeAt(n));\n    return t;\n  }(t));\n}\nfunction C(e, t) {\n  return Object.prototype.hasOwnProperty.call(e, t);\n}\nvar P,\n  S = {\n    appendUrlPath: function (e, t) {\n      return (e.endsWith(\"/\") ? e.substring(0, e.length - 1) : e) + (t.startsWith(\"/\") ? \"\" : \"/\") + t;\n    },\n    base64URLEncode: function (e) {\n      return O(e).replace(/=/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n    },\n    btoa: O,\n    clone: function (e) {\n      return JSON.parse(JSON.stringify(e));\n    },\n    deepEquals: function (e, t) {\n      return D(e, t);\n    },\n    extend: function (...e) {\n      return e.reduce((e, t) => ({\n        ...e,\n        ...t\n      }), {});\n    },\n    getLDUserAgentString: function (e) {\n      const t = e.version || \"?\";\n      return e.userAgent + \"/\" + t;\n    },\n    objectHasOwnProperty: C,\n    onNextTick: function (e) {\n      setTimeout(e, 0);\n    },\n    sanitizeContext: function (e) {\n      if (!e) return e;\n      let t;\n      return null !== e.kind && void 0 !== e.kind || x.forEach(n => {\n        const r = e[n];\n        void 0 !== r && \"string\" != typeof r && (t = t || {\n          ...e\n        }, t[n] = String(r));\n      }), t || e;\n    },\n    transformValuesToVersionedValues: function (e) {\n      const t = {};\n      for (const n in e) C(e, n) && (t[n] = {\n        value: e[n],\n        version: 0\n      });\n      return t;\n    },\n    transformVersionedValuesToValues: function (e) {\n      const t = {};\n      for (const n in e) C(e, n) && (t[n] = e[n].value);\n      return t;\n    },\n    wrapPromiseCallback: function (e, t) {\n      const n = e.then(e => (t && setTimeout(() => {\n        t(null, e);\n      }, 0), e), e => {\n        if (!t) return Promise.reject(e);\n        setTimeout(() => {\n          t(e, null);\n        }, 0);\n      });\n      return t ? void 0 : n;\n    },\n    once: function (e) {\n      let t,\n        n = !1;\n      return function (...r) {\n        return n || (n = !0, t = e.apply(this, r)), t;\n      };\n    }\n  },\n  I = new Uint8Array(16);\nfunction T() {\n  if (!P && !(P = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || \"undefined\" != typeof msCrypto && \"function\" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return P(I);\n}\nvar F = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nfunction L(e) {\n  return \"string\" == typeof e && F.test(e);\n}\nfor (var U, A, j = [], R = 0; R < 256; ++R) j.push((R + 256).toString(16).substr(1));\nfunction N(e) {\n  var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,\n    n = (j[e[t + 0]] + j[e[t + 1]] + j[e[t + 2]] + j[e[t + 3]] + \"-\" + j[e[t + 4]] + j[e[t + 5]] + \"-\" + j[e[t + 6]] + j[e[t + 7]] + \"-\" + j[e[t + 8]] + j[e[t + 9]] + \"-\" + j[e[t + 10]] + j[e[t + 11]] + j[e[t + 12]] + j[e[t + 13]] + j[e[t + 14]] + j[e[t + 15]]).toLowerCase();\n  if (!L(n)) throw TypeError(\"Stringified UUID is invalid\");\n  return n;\n}\nvar $ = 0,\n  V = 0;\nfunction H(e) {\n  if (!L(e)) throw TypeError(\"Invalid UUID\");\n  var t,\n    n = new Uint8Array(16);\n  return n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, n[1] = t >>> 16 & 255, n[2] = t >>> 8 & 255, n[3] = 255 & t, n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, n[5] = 255 & t, n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, n[7] = 255 & t, n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, n[9] = 255 & t, n[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = t / 4294967296 & 255, n[12] = t >>> 24 & 255, n[13] = t >>> 16 & 255, n[14] = t >>> 8 & 255, n[15] = 255 & t, n;\n}\nfunction M(e, t, n) {\n  function r(e, r, o, i) {\n    if (\"string\" == typeof e && (e = function (e) {\n      e = unescape(encodeURIComponent(e));\n      for (var t = [], n = 0; n < e.length; ++n) t.push(e.charCodeAt(n));\n      return t;\n    }(e)), \"string\" == typeof r && (r = H(r)), 16 !== r.length) throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n    var a = new Uint8Array(16 + e.length);\n    if (a.set(r), a.set(e, r.length), (a = n(a))[6] = 15 & a[6] | t, a[8] = 63 & a[8] | 128, o) {\n      i = i || 0;\n      for (var s = 0; s < 16; ++s) o[i + s] = a[s];\n      return o;\n    }\n    return N(a);\n  }\n  try {\n    r.name = e;\n  } catch (e) {}\n  return r.DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\", r.URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\", r;\n}\nfunction q(e) {\n  return 14 + (e + 64 >>> 9 << 4) + 1;\n}\nfunction z(e, t) {\n  var n = (65535 & e) + (65535 & t);\n  return (e >> 16) + (t >> 16) + (n >> 16) << 16 | 65535 & n;\n}\nfunction K(e, t, n, r, o, i) {\n  return z((a = z(z(t, e), z(r, i))) << (s = o) | a >>> 32 - s, n);\n  var a, s;\n}\nfunction _(e, t, n, r, o, i, a) {\n  return K(t & n | ~t & r, e, t, o, i, a);\n}\nfunction J(e, t, n, r, o, i, a) {\n  return K(t & r | n & ~r, e, t, o, i, a);\n}\nfunction B(e, t, n, r, o, i, a) {\n  return K(t ^ n ^ r, e, t, o, i, a);\n}\nfunction W(e, t, n, r, o, i, a) {\n  return K(n ^ (t | ~r), e, t, o, i, a);\n}\nvar G = M(\"v3\", 48, function (e) {\n    if (\"string\" == typeof e) {\n      var t = unescape(encodeURIComponent(e));\n      e = new Uint8Array(t.length);\n      for (var n = 0; n < t.length; ++n) e[n] = t.charCodeAt(n);\n    }\n    return function (e) {\n      for (var t = [], n = 32 * e.length, r = \"0123456789abcdef\", o = 0; o < n; o += 8) {\n        var i = e[o >> 5] >>> o % 32 & 255,\n          a = parseInt(r.charAt(i >>> 4 & 15) + r.charAt(15 & i), 16);\n        t.push(a);\n      }\n      return t;\n    }(function (e, t) {\n      e[t >> 5] |= 128 << t % 32, e[q(t) - 1] = t;\n      for (var n = 1732584193, r = -271733879, o = -1732584194, i = 271733878, a = 0; a < e.length; a += 16) {\n        var s = n,\n          c = r,\n          u = o,\n          l = i;\n        n = _(n, r, o, i, e[a], 7, -680876936), i = _(i, n, r, o, e[a + 1], 12, -389564586), o = _(o, i, n, r, e[a + 2], 17, 606105819), r = _(r, o, i, n, e[a + 3], 22, -1044525330), n = _(n, r, o, i, e[a + 4], 7, -176418897), i = _(i, n, r, o, e[a + 5], 12, 1200080426), o = _(o, i, n, r, e[a + 6], 17, -1473231341), r = _(r, o, i, n, e[a + 7], 22, -45705983), n = _(n, r, o, i, e[a + 8], 7, 1770035416), i = _(i, n, r, o, e[a + 9], 12, -1958414417), o = _(o, i, n, r, e[a + 10], 17, -42063), r = _(r, o, i, n, e[a + 11], 22, -1990404162), n = _(n, r, o, i, e[a + 12], 7, 1804603682), i = _(i, n, r, o, e[a + 13], 12, -40341101), o = _(o, i, n, r, e[a + 14], 17, -1502002290), n = J(n, r = _(r, o, i, n, e[a + 15], 22, 1236535329), o, i, e[a + 1], 5, -165796510), i = J(i, n, r, o, e[a + 6], 9, -1069501632), o = J(o, i, n, r, e[a + 11], 14, 643717713), r = J(r, o, i, n, e[a], 20, -373897302), n = J(n, r, o, i, e[a + 5], 5, -701558691), i = J(i, n, r, o, e[a + 10], 9, 38016083), o = J(o, i, n, r, e[a + 15], 14, -660478335), r = J(r, o, i, n, e[a + 4], 20, -405537848), n = J(n, r, o, i, e[a + 9], 5, 568446438), i = J(i, n, r, o, e[a + 14], 9, -1019803690), o = J(o, i, n, r, e[a + 3], 14, -187363961), r = J(r, o, i, n, e[a + 8], 20, 1163531501), n = J(n, r, o, i, e[a + 13], 5, -1444681467), i = J(i, n, r, o, e[a + 2], 9, -51403784), o = J(o, i, n, r, e[a + 7], 14, 1735328473), n = B(n, r = J(r, o, i, n, e[a + 12], 20, -1926607734), o, i, e[a + 5], 4, -378558), i = B(i, n, r, o, e[a + 8], 11, -2022574463), o = B(o, i, n, r, e[a + 11], 16, 1839030562), r = B(r, o, i, n, e[a + 14], 23, -35309556), n = B(n, r, o, i, e[a + 1], 4, -1530992060), i = B(i, n, r, o, e[a + 4], 11, 1272893353), o = B(o, i, n, r, e[a + 7], 16, -155497632), r = B(r, o, i, n, e[a + 10], 23, -1094730640), n = B(n, r, o, i, e[a + 13], 4, 681279174), i = B(i, n, r, o, e[a], 11, -358537222), o = B(o, i, n, r, e[a + 3], 16, -722521979), r = B(r, o, i, n, e[a + 6], 23, 76029189), n = B(n, r, o, i, e[a + 9], 4, -640364487), i = B(i, n, r, o, e[a + 12], 11, -421815835), o = B(o, i, n, r, e[a + 15], 16, 530742520), n = W(n, r = B(r, o, i, n, e[a + 2], 23, -995338651), o, i, e[a], 6, -198630844), i = W(i, n, r, o, e[a + 7], 10, 1126891415), o = W(o, i, n, r, e[a + 14], 15, -1416354905), r = W(r, o, i, n, e[a + 5], 21, -57434055), n = W(n, r, o, i, e[a + 12], 6, 1700485571), i = W(i, n, r, o, e[a + 3], 10, -1894986606), o = W(o, i, n, r, e[a + 10], 15, -1051523), r = W(r, o, i, n, e[a + 1], 21, -2054922799), n = W(n, r, o, i, e[a + 8], 6, 1873313359), i = W(i, n, r, o, e[a + 15], 10, -30611744), o = W(o, i, n, r, e[a + 6], 15, -1560198380), r = W(r, o, i, n, e[a + 13], 21, 1309151649), n = W(n, r, o, i, e[a + 4], 6, -145523070), i = W(i, n, r, o, e[a + 11], 10, -1120210379), o = W(o, i, n, r, e[a + 2], 15, 718787259), r = W(r, o, i, n, e[a + 9], 21, -343485551), n = z(n, s), r = z(r, c), o = z(o, u), i = z(i, l);\n      }\n      return [n, r, o, i];\n    }(function (e) {\n      if (0 === e.length) return [];\n      for (var t = 8 * e.length, n = new Uint32Array(q(t)), r = 0; r < t; r += 8) n[r >> 5] |= (255 & e[r / 8]) << r % 32;\n      return n;\n    }(e), 8 * e.length));\n  }),\n  X = G;\nfunction Q(e, t, n, r) {\n  switch (e) {\n    case 0:\n      return t & n ^ ~t & r;\n    case 1:\n    case 3:\n      return t ^ n ^ r;\n    case 2:\n      return t & n ^ t & r ^ n & r;\n  }\n}\nfunction Y(e, t) {\n  return e << t | e >>> 32 - t;\n}\nvar Z = M(\"v5\", 80, function (e) {\n    var t = [1518500249, 1859775393, 2400959708, 3395469782],\n      n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n    if (\"string\" == typeof e) {\n      var r = unescape(encodeURIComponent(e));\n      e = [];\n      for (var o = 0; o < r.length; ++o) e.push(r.charCodeAt(o));\n    } else Array.isArray(e) || (e = Array.prototype.slice.call(e));\n    e.push(128);\n    for (var i = e.length / 4 + 2, a = Math.ceil(i / 16), s = new Array(a), c = 0; c < a; ++c) {\n      for (var u = new Uint32Array(16), l = 0; l < 16; ++l) u[l] = e[64 * c + 4 * l] << 24 | e[64 * c + 4 * l + 1] << 16 | e[64 * c + 4 * l + 2] << 8 | e[64 * c + 4 * l + 3];\n      s[c] = u;\n    }\n    s[a - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), s[a - 1][14] = Math.floor(s[a - 1][14]), s[a - 1][15] = 8 * (e.length - 1) & 4294967295;\n    for (var d = 0; d < a; ++d) {\n      for (var f = new Uint32Array(80), g = 0; g < 16; ++g) f[g] = s[d][g];\n      for (var v = 16; v < 80; ++v) f[v] = Y(f[v - 3] ^ f[v - 8] ^ f[v - 14] ^ f[v - 16], 1);\n      for (var p = n[0], m = n[1], h = n[2], y = n[3], w = n[4], b = 0; b < 80; ++b) {\n        var k = Math.floor(b / 20),\n          E = Y(p, 5) + Q(k, m, h, y) + w + t[k] + f[b] >>> 0;\n        w = y, y = h, h = Y(m, 30) >>> 0, m = p, p = E;\n      }\n      n[0] = n[0] + p >>> 0, n[1] = n[1] + m >>> 0, n[2] = n[2] + h >>> 0, n[3] = n[3] + y >>> 0, n[4] = n[4] + w >>> 0;\n    }\n    return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, 255 & n[0], n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, 255 & n[1], n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, 255 & n[2], n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, 255 & n[3], n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, 255 & n[4]];\n  }),\n  ee = Z;\nvar te = Object.freeze({\n  __proto__: null,\n  v1: function (e, t, n) {\n    var r = t && n || 0,\n      o = t || new Array(16),\n      i = (e = e || {}).node || U,\n      a = void 0 !== e.clockseq ? e.clockseq : A;\n    if (null == i || null == a) {\n      var s = e.random || (e.rng || T)();\n      null == i && (i = U = [1 | s[0], s[1], s[2], s[3], s[4], s[5]]), null == a && (a = A = 16383 & (s[6] << 8 | s[7]));\n    }\n    var c = void 0 !== e.msecs ? e.msecs : Date.now(),\n      u = void 0 !== e.nsecs ? e.nsecs : V + 1,\n      l = c - $ + (u - V) / 1e4;\n    if (l < 0 && void 0 === e.clockseq && (a = a + 1 & 16383), (l < 0 || c > $) && void 0 === e.nsecs && (u = 0), u >= 1e4) throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    $ = c, V = u, A = a;\n    var d = (1e4 * (268435455 & (c += 122192928e5)) + u) % 4294967296;\n    o[r++] = d >>> 24 & 255, o[r++] = d >>> 16 & 255, o[r++] = d >>> 8 & 255, o[r++] = 255 & d;\n    var f = c / 4294967296 * 1e4 & 268435455;\n    o[r++] = f >>> 8 & 255, o[r++] = 255 & f, o[r++] = f >>> 24 & 15 | 16, o[r++] = f >>> 16 & 255, o[r++] = a >>> 8 | 128, o[r++] = 255 & a;\n    for (var g = 0; g < 6; ++g) o[r + g] = i[g];\n    return t || N(o);\n  },\n  v3: X,\n  v4: function (e, t, n) {\n    var r = (e = e || {}).random || (e.rng || T)();\n    if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) {\n      n = n || 0;\n      for (var o = 0; o < 16; ++o) t[n + o] = r[o];\n      return t;\n    }\n    return N(r);\n  },\n  v5: ee,\n  NIL: \"00000000-0000-0000-0000-000000000000\",\n  version: function (e) {\n    if (!L(e)) throw TypeError(\"Invalid UUID\");\n    return parseInt(e.substr(14, 1), 16);\n  },\n  validate: L,\n  stringify: N,\n  parse: H\n});\nconst ne = [\"debug\", \"info\", \"warn\", \"error\", \"none\"];\nvar re = {\n  commonBasicLogger: function (e, t) {\n    if (e && e.destination && \"function\" != typeof e.destination) throw new Error(\"destination for basicLogger was set to a non-function\");\n    function n(e) {\n      return function (t) {\n        console && console[e] && console[e].call(console, t);\n      };\n    }\n    const r = e && e.destination ? [e.destination, e.destination, e.destination, e.destination] : [n(\"log\"), n(\"info\"), n(\"warn\"), n(\"error\")],\n      o = !(!e || !e.destination),\n      i = e && void 0 !== e.prefix && null !== e.prefix ? e.prefix : \"[LaunchDarkly] \";\n    let a = 1;\n    if (e && e.level) for (let t = 0; t < ne.length; t++) ne[t] === e.level && (a = t);\n    function s(e, n, a) {\n      if (a.length < 1) return;\n      let s;\n      const c = o ? n + \": \" + i : i;\n      if (1 !== a.length && t) {\n        const e = [...a];\n        e[0] = c + e[0], s = t(...e);\n      } else s = c + a[0];\n      try {\n        r[e](s);\n      } catch (e) {\n        console && console.log && console.log(\"[LaunchDarkly] Configured logger's \" + n + \" method threw an exception: \" + e);\n      }\n    }\n    const c = {};\n    for (let e = 0; e < ne.length; e++) {\n      const t = ne[e];\n      if (\"none\" !== t) if (e < a) c[t] = () => {};else {\n        const n = e;\n        c[t] = function () {\n          s(n, t, arguments);\n        };\n      }\n    }\n    return c;\n  },\n  validateLogger: function (e) {\n    ne.forEach(t => {\n      if (\"none\" !== t && (!e[t] || \"function\" != typeof e[t])) throw new Error(\"Provided logger instance must support logger.\" + t + \"(...) method\");\n    });\n  }\n};\nfunction oe(e) {\n  return e && e.message ? e.message : \"string\" == typeof e || e instanceof String ? e : JSON.stringify(e);\n}\nconst ie = \" Please see https://docs.launchdarkly.com/sdk/client-side/javascript#initialize-the-client for instructions on SDK initialization.\";\nvar ae = {\n  bootstrapInvalid: function () {\n    return \"LaunchDarkly bootstrap data is not available because the back end could not read the flags.\";\n  },\n  bootstrapOldFormat: function () {\n    return \"LaunchDarkly client was initialized with bootstrap data that did not include flag metadata. Events may not be sent correctly.\" + ie;\n  },\n  clientInitialized: function () {\n    return \"LaunchDarkly client initialized\";\n  },\n  clientNotReady: function () {\n    return \"LaunchDarkly client is not ready\";\n  },\n  debugEnqueueingEvent: function (e) {\n    return 'enqueueing \"' + e + '\" event';\n  },\n  debugPostingDiagnosticEvent: function (e) {\n    return \"sending diagnostic event (\" + e.kind + \")\";\n  },\n  debugPostingEvents: function (e) {\n    return \"sending \" + e + \" events\";\n  },\n  debugStreamDelete: function (e) {\n    return 'received streaming deletion for flag \"' + e + '\"';\n  },\n  debugStreamDeleteIgnored: function (e) {\n    return 'received streaming deletion for flag \"' + e + '\" but ignored due to version check';\n  },\n  debugStreamPatch: function (e) {\n    return 'received streaming update for flag \"' + e + '\"';\n  },\n  debugStreamPatchIgnored: function (e) {\n    return 'received streaming update for flag \"' + e + '\" but ignored due to version check';\n  },\n  debugStreamPing: function () {\n    return \"received ping message from stream\";\n  },\n  debugPolling: function (e) {\n    return \"polling for feature flags at \" + e;\n  },\n  debugStreamPut: function () {\n    return \"received streaming update for all flags\";\n  },\n  deprecated: function (e, t) {\n    return t ? '\"' + e + '\" is deprecated, please use \"' + t + '\"' : '\"' + e + '\" is deprecated';\n  },\n  environmentNotFound: function () {\n    return \"Environment not found. Double check that you specified a valid environment/client-side ID.\" + ie;\n  },\n  environmentNotSpecified: function () {\n    return \"No environment/client-side ID was specified.\" + ie;\n  },\n  errorFetchingFlags: function (e) {\n    return \"Error fetching flag settings: \" + oe(e);\n  },\n  eventCapacityExceeded: function () {\n    return \"Exceeded event queue capacity. Increase capacity to avoid dropping events.\";\n  },\n  eventWithoutContext: function () {\n    return \"Be sure to call `identify` in the LaunchDarkly client: https://docs.launchdarkly.com/sdk/features/identify#javascript\";\n  },\n  httpErrorMessage: function (e, t, n) {\n    return \"Received error \" + e + (401 === e ? \" (invalid SDK key)\" : \"\") + \" for \" + t + \" - \" + (s.isHttpErrorRecoverable(e) ? n : \"giving up permanently\");\n  },\n  httpUnavailable: function () {\n    return \"Cannot make HTTP requests in this environment.\" + ie;\n  },\n  identifyDisabled: function () {\n    return \"identify() has no effect here; it must be called on the main client instance\";\n  },\n  inspectorMethodError: (e, t) => `an inspector: \"${t}\" of type: \"${e}\" generated an exception`,\n  invalidContentType: function (e) {\n    return 'Expected application/json content type but got \"' + e + '\"';\n  },\n  invalidData: function () {\n    return \"Invalid data received from LaunchDarkly; connection may have been interrupted\";\n  },\n  invalidInspector: (e, t) => `an inspector: \"${t}\" of an invalid type (${e}) was configured`,\n  invalidKey: function () {\n    return \"Event key must be a string\";\n  },\n  invalidMetricValue: e => `The track function was called with a non-numeric \"metricValue\" (${e}), only numeric metric values are supported.`,\n  invalidContext: function () {\n    return \"Invalid context specified.\" + ie;\n  },\n  invalidTagValue: e => `Config option \"${e}\" must only contain letters, numbers, ., _ or -.`,\n  localStorageUnavailable: function (e) {\n    return \"local storage is unavailable: \" + oe(e);\n  },\n  networkError: e => \"network error\" + (e ? \" (\" + e + \")\" : \"\"),\n  optionBelowMinimum: (e, t, n) => 'Config option \"' + e + '\" was set to ' + t + \", changing to minimum value of \" + n,\n  streamClosing: function () {\n    return \"Closing stream connection\";\n  },\n  streamConnecting: function (e) {\n    return \"Opening stream connection to \" + e;\n  },\n  streamError: function (e, t) {\n    return \"Error on stream connection: \" + oe(e) + \", will continue retrying after \" + t + \" milliseconds.\";\n  },\n  tagValueTooLong: e => `Value of \"${e}\" was longer than 64 characters and was discarded.`,\n  unknownCustomEventKey: function (e) {\n    return 'Custom event \"' + e + '\" does not exist';\n  },\n  unknownOption: e => 'Ignoring unknown config option \"' + e + '\"',\n  contextNotSpecified: function () {\n    return \"No context specified.\" + ie;\n  },\n  unrecoverableStreamError: e => `Error on stream connection ${oe(e)}, giving up permanently`,\n  wrongOptionType: (e, t, n) => 'Config option \"' + e + '\" should be of type ' + t + \", got \" + n + \", using default value\",\n  wrongOptionTypeBoolean: (e, t) => 'Config option \"' + e + '\" should be a boolean, got ' + t + \", converting to boolean\"\n};\nconst {\n    validateLogger: se\n  } = re,\n  ce = {\n    baseUrl: {\n      default: \"https://app.launchdarkly.com\"\n    },\n    streamUrl: {\n      default: \"https://clientstream.launchdarkly.com\"\n    },\n    eventsUrl: {\n      default: \"https://events.launchdarkly.com\"\n    },\n    sendEvents: {\n      default: !0\n    },\n    streaming: {\n      type: \"boolean\"\n    },\n    sendLDHeaders: {\n      default: !0\n    },\n    requestHeaderTransform: {\n      type: \"function\"\n    },\n    sendEventsOnlyForVariation: {\n      default: !1\n    },\n    useReport: {\n      default: !1\n    },\n    evaluationReasons: {\n      default: !1\n    },\n    eventCapacity: {\n      default: 100,\n      minimum: 1\n    },\n    flushInterval: {\n      default: 2e3,\n      minimum: 2e3\n    },\n    samplingInterval: {\n      default: 0,\n      minimum: 0\n    },\n    streamReconnectDelay: {\n      default: 1e3,\n      minimum: 0\n    },\n    allAttributesPrivate: {\n      default: !1\n    },\n    privateAttributes: {\n      default: []\n    },\n    bootstrap: {\n      type: \"string|object\"\n    },\n    diagnosticRecordingInterval: {\n      default: 9e5,\n      minimum: 2e3\n    },\n    diagnosticOptOut: {\n      default: !1\n    },\n    wrapperName: {\n      type: \"string\"\n    },\n    wrapperVersion: {\n      type: \"string\"\n    },\n    stateProvider: {\n      type: \"object\"\n    },\n    application: {\n      validator: function (e, t, n) {\n        const r = {};\n        t.id && (r.id = de(`${e}.id`, t.id, n));\n        t.version && (r.version = de(`${e}.version`, t.version, n));\n        return r;\n      }\n    },\n    inspectors: {\n      default: []\n    },\n    hooks: {\n      default: []\n    },\n    plugins: {\n      default: []\n    }\n  },\n  ue = /^(\\w|\\.|-)+$/;\nfunction le(e) {\n  return e && e.replace(/\\/+$/, \"\");\n}\nfunction de(e, t, n) {\n  if (\"string\" == typeof t && t.match(ue)) {\n    if (!(t.length > 64)) return t;\n    n.warn(ae.tagValueTooLong(e));\n  } else n.warn(ae.invalidTagValue(e));\n}\nvar fe = {\n  baseOptionDefs: ce,\n  validate: function (e, t, n, r) {\n    const o = S.extend({\n        logger: {\n          default: r\n        }\n      }, ce, n),\n      i = {};\n    function a(e) {\n      S.onNextTick(() => {\n        t && t.maybeReportError(new s.LDInvalidArgumentError(e));\n      });\n    }\n    let c = S.extend({}, e || {});\n    return function (e) {\n      const t = e;\n      Object.keys(i).forEach(e => {\n        if (void 0 !== t[e]) {\n          const n = i[e];\n          r && r.warn(ae.deprecated(e, n)), n && (void 0 === t[n] && (t[n] = t[e]), delete t[e]);\n        }\n      });\n    }(c), c = function (e) {\n      const t = S.extend({}, e);\n      return Object.keys(o).forEach(e => {\n        void 0 !== t[e] && null !== t[e] || (t[e] = o[e] && o[e].default);\n      }), t;\n    }(c), c = function (e) {\n      const t = S.extend({}, e),\n        n = e => {\n          if (null === e) return \"any\";\n          if (void 0 === e) return;\n          if (Array.isArray(e)) return \"array\";\n          const t = typeof e;\n          return \"boolean\" === t || \"string\" === t || \"number\" === t || \"function\" === t ? t : \"object\";\n        };\n      return Object.keys(e).forEach(i => {\n        const s = e[i];\n        if (null != s) {\n          const c = o[i];\n          if (void 0 === c) a(ae.unknownOption(i));else {\n            const o = c.type || n(c.default),\n              u = c.validator;\n            if (u) {\n              const n = u(i, e[i], r);\n              void 0 !== n ? t[i] = n : delete t[i];\n            } else if (\"any\" !== o) {\n              const e = o.split(\"|\"),\n                r = n(s);\n              e.indexOf(r) < 0 ? \"boolean\" === o ? (t[i] = !!s, a(ae.wrongOptionTypeBoolean(i, r))) : (a(ae.wrongOptionType(i, o, r)), t[i] = c.default) : \"number\" === r && void 0 !== c.minimum && s < c.minimum && (a(ae.optionBelowMinimum(i, s, c.minimum)), t[i] = c.minimum);\n            }\n          }\n        }\n      }), t.baseUrl = le(t.baseUrl), t.streamUrl = le(t.streamUrl), t.eventsUrl = le(t.eventsUrl), t;\n    }(c), se(c.logger), c;\n  },\n  getTags: function (e) {\n    const t = {};\n    return e && (e.application && void 0 !== e.application.id && null !== e.application.id && (t[\"application-id\"] = [e.application.id]), e.application && void 0 !== e.application.version && null !== e.application.id && (t[\"application-version\"] = [e.application.version])), t;\n  }\n};\nconst {\n  getLDUserAgentString: ge\n} = S;\nvar ve = {\n  getLDHeaders: function (e, t) {\n    if (t && !t.sendLDHeaders) return {};\n    const n = {};\n    n[e.userAgentHeaderName || \"User-Agent\"] = ge(e), t && t.wrapperName && (n[\"X-LaunchDarkly-Wrapper\"] = t.wrapperVersion ? t.wrapperName + \"/\" + t.wrapperVersion : t.wrapperName);\n    const r = fe.getTags(t),\n      o = Object.keys(r);\n    return o.length && (n[\"x-launchdarkly-tags\"] = o.sort().map(e => Array.isArray(r[e]) ? r[e].sort().map(t => `${e}/${t}`) : [`${e}/${r[e]}`]).reduce((e, t) => e.concat(t), []).join(\" \")), n;\n  },\n  transformHeaders: function (e, t) {\n    return t && t.requestHeaderTransform ? t.requestHeaderTransform({\n      ...e\n    }) : e;\n  }\n};\nconst {\n    v1: pe\n  } = te,\n  {\n    getLDHeaders: me,\n    transformHeaders: he\n  } = ve;\nvar ye = function (e, t, n) {\n  const r = S.extend({\n      \"Content-Type\": \"application/json\"\n    }, me(e, n)),\n    o = {};\n  return o.sendEvents = (t, o, i) => {\n    if (!e.httpRequest) return Promise.resolve();\n    const a = JSON.stringify(t),\n      c = i ? null : pe();\n    return function t(u) {\n      const l = i ? r : S.extend({}, r, {\n        \"X-LaunchDarkly-Event-Schema\": \"4\",\n        \"X-LaunchDarkly-Payload-ID\": c\n      });\n      return e.httpRequest(\"POST\", o, he(l, n), a).promise.then(e => {\n        if (e) return e.status >= 400 && s.isHttpErrorRecoverable(e.status) && u ? t(!1) : function (e) {\n          const t = {\n              status: e.status\n            },\n            n = e.header(\"date\");\n          if (n) {\n            const e = Date.parse(n);\n            e && (t.serverTime = e);\n          }\n          return t;\n        }(e);\n      }).catch(() => u ? t(!1) : Promise.reject());\n    }(!0).catch(() => {});\n  }, o;\n};\nvar we = function e(t, n = []) {\n  if (null === t || \"object\" != typeof t) return JSON.stringify(t);\n  if (n.includes(t)) throw new Error(\"Cycle detected\");\n  if (Array.isArray(t)) {\n    return `[${t.map(r => e(r, [...n, t])).map(e => void 0 === e ? \"null\" : e).join(\",\")}]`;\n  }\n  return `{${Object.keys(t).sort().map(r => {\n    const o = e(t[r], [...n, t]);\n    if (void 0 !== o) return `${JSON.stringify(r)}:${o}`;\n  }).filter(e => void 0 !== e).join(\",\")}}`;\n};\nconst {\n  commonBasicLogger: be\n} = re;\nfunction ke(e) {\n  return \"string\" == typeof e && \"kind\" !== e && e.match(/^(\\w|\\.|-)+$/);\n}\nfunction Ee(e) {\n  return e.includes(\"%\") || e.includes(\":\") ? e.replace(/%/g, \"%25\").replace(/:/g, \"%3A\") : e;\n}\nvar De = {\n  checkContext: function (e, t) {\n    if (e) {\n      if (t && (void 0 === e.kind || null === e.kind)) return void 0 !== e.key && null !== e.key;\n      const n = e.key,\n        r = void 0 === e.kind ? \"user\" : e.kind,\n        o = ke(r),\n        i = \"multi\" === r || null != n && \"\" !== n;\n      if (\"multi\" === r) {\n        const t = Object.keys(e).filter(e => \"kind\" !== e);\n        return i && t.every(e => ke(e)) && t.every(t => {\n          const n = e[t].key;\n          return null != n && \"\" !== n;\n        });\n      }\n      return i && o;\n    }\n    return !1;\n  },\n  getContextKeys: function (e, t = be()) {\n    if (!e) return;\n    const n = {},\n      {\n        kind: r,\n        key: o\n      } = e;\n    switch (r) {\n      case void 0:\n        n.user = `${o}`;\n        break;\n      case \"multi\":\n        Object.entries(e).filter(([e]) => \"kind\" !== e).forEach(([e, t]) => {\n          t && t.key && (n[e] = t.key);\n        });\n        break;\n      case null:\n        t.warn(`null is not a valid context kind: ${e}`);\n        break;\n      case \"\":\n        t.warn(`'' is not a valid context kind: ${e}`);\n        break;\n      default:\n        n[r] = `${o}`;\n    }\n    return n;\n  },\n  getContextKinds: function (e) {\n    return e ? null === e.kind || void 0 === e.kind ? [\"user\"] : \"multi\" !== e.kind ? [e.kind] : Object.keys(e).filter(e => \"kind\" !== e) : [];\n  },\n  getCanonicalKey: function (e) {\n    if (e) {\n      if ((void 0 === e.kind || null === e.kind || \"user\" === e.kind) && e.key) return e.key;\n      if (\"multi\" !== e.kind && e.key) return `${e.kind}:${Ee(e.key)}`;\n      if (\"multi\" === e.kind) return Object.keys(e).sort().filter(e => \"kind\" !== e).map(t => `${t}:${Ee(e[t].key)}`).join(\":\");\n    }\n  }\n};\nconst {\n  getContextKinds: xe\n} = De;\nvar Oe = function () {\n  const e = {};\n  let t = 0,\n    n = 0,\n    r = {},\n    o = {};\n  return e.summarizeEvent = e => {\n    if (\"feature\" === e.kind) {\n      const i = e.key + \":\" + (null !== e.variation && void 0 !== e.variation ? e.variation : \"\") + \":\" + (null !== e.version && void 0 !== e.version ? e.version : \"\"),\n        a = r[i];\n      let s = o[e.key];\n      s || (s = new Set(), o[e.key] = s), function (e) {\n        return e.context ? xe(e.context) : e.contextKeys ? Object.keys(e.contextKeys) : [];\n      }(e).forEach(e => s.add(e)), a ? a.count = a.count + 1 : r[i] = {\n        count: 1,\n        key: e.key,\n        version: e.version,\n        variation: e.variation,\n        value: e.value,\n        default: e.default\n      }, (0 === t || e.creationDate < t) && (t = e.creationDate), e.creationDate > n && (n = e.creationDate);\n    }\n  }, e.getSummary = () => {\n    const e = {};\n    let i = !0;\n    for (const t of Object.values(r)) {\n      let n = e[t.key];\n      n || (n = {\n        default: t.default,\n        counters: [],\n        contextKinds: [...o[t.key]]\n      }, e[t.key] = n);\n      const r = {\n        value: t.value,\n        count: t.count\n      };\n      void 0 !== t.variation && null !== t.variation && (r.variation = t.variation), void 0 !== t.version && null !== t.version ? r.version = t.version : r.unknown = !0, n.counters.push(r), i = !1;\n    }\n    return i ? null : {\n      startDate: t,\n      endDate: n,\n      features: e,\n      kind: \"summary\"\n    };\n  }, e.clearSummary = () => {\n    t = 0, n = 0, r = {}, o = {};\n  }, e;\n};\nvar Ce = function (e) {\n  let t = {},\n    n = {};\n  return {\n    summarizeEvent: function (e) {\n      if (\"feature\" === e.kind) {\n        const r = we(e.context);\n        if (!r) return;\n        let o = t[r];\n        o || (t[r] = Oe(), o = t[r], n[r] = e.context), o.summarizeEvent(e);\n      }\n    },\n    getSummaries: function () {\n      const r = t,\n        o = n;\n      return t = {}, n = {}, Object.entries(r).map(([t, n]) => {\n        const r = n.getSummary();\n        return r.context = e.filter(o[t]), r;\n      });\n    }\n  };\n};\nfunction Pe(e) {\n  return e.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\nfunction Se(e) {\n  return (e.startsWith(\"/\") ? e.substring(1) : e).split(\"/\").map(e => e.indexOf(\"~\") >= 0 ? e.replace(/~1/g, \"/\").replace(/~0/g, \"~\") : e);\n}\nfunction Ie(e) {\n  return !e.startsWith(\"/\");\n}\nfunction Te(e, t) {\n  const n = Ie(e),\n    r = Ie(t);\n  if (n && r) return e === t;\n  if (n) {\n    const n = Se(t);\n    return 1 === n.length && e === n[0];\n  }\n  if (r) {\n    const n = Se(e);\n    return 1 === n.length && t === n[0];\n  }\n  return e === t;\n}\nfunction Fe(e) {\n  return `/${Pe(e)}`;\n}\nvar Le = {\n  cloneExcluding: function (e, t) {\n    const n = [],\n      r = {},\n      o = [];\n    for (n.push(...Object.keys(e).map(t => ({\n      key: t,\n      ptr: Fe(t),\n      source: e,\n      parent: r,\n      visited: [e]\n    }))); n.length;) {\n      const e = n.pop();\n      if (t.some(t => Te(t, e.ptr))) o.push(e.ptr);else {\n        const t = e.source[e.key];\n        if (null === t) e.parent[e.key] = t;else if (Array.isArray(t)) e.parent[e.key] = [...t];else if (\"object\" == typeof t) {\n          if (e.visited.includes(t)) continue;\n          e.parent[e.key] = {}, n.push(...Object.keys(t).map(n => {\n            return {\n              key: n,\n              ptr: (r = e.ptr, o = Pe(n), `${r}/${o}`),\n              source: t,\n              parent: e.parent[e.key],\n              visited: [...e.visited, t]\n            };\n            var r, o;\n          }));\n        } else e.parent[e.key] = t;\n      }\n    }\n    return {\n      cloned: r,\n      excluded: o.sort()\n    };\n  },\n  compare: Te,\n  literalToReference: Fe\n};\nvar Ue = function (e) {\n  const t = {},\n    n = e.allAttributesPrivate,\n    r = e.privateAttributes || [],\n    o = [\"key\", \"kind\", \"_meta\", \"anonymous\"],\n    i = [\"name\", \"ip\", \"firstName\", \"lastName\", \"email\", \"avatar\", \"country\"],\n    a = (e, t) => {\n      if (\"object\" != typeof e || null === e || Array.isArray(e)) return;\n      const {\n        cloned: i,\n        excluded: a\n      } = Le.cloneExcluding(e, ((e, t) => (n || t && e.anonymous ? Object.keys(e) : [...r, ...(e._meta && e._meta.privateAttributes || [])]).filter(e => !o.some(t => Le.compare(e, t))))(e, t));\n      return i.key = String(i.key), a.length && (i._meta || (i._meta = {}), i._meta.redactedAttributes = a), i._meta && (delete i._meta.privateAttributes, 0 === Object.keys(i._meta).length && delete i._meta), void 0 !== i.anonymous && (i.anonymous = !!i.anonymous), i;\n    };\n  return t.filter = (e, t = !1) => void 0 === e.kind || null === e.kind ? a((e => {\n    const t = {\n      ...(e.custom || {}),\n      kind: \"user\",\n      key: e.key\n    };\n    void 0 !== e.anonymous && (t.anonymous = !!e.anonymous);\n    for (const n of i) delete t[n], void 0 !== e[n] && null !== e[n] && (t[n] = String(e[n]));\n    return void 0 !== e.privateAttributeNames && null !== e.privateAttributeNames && (t._meta = t._meta || {}, t._meta.privateAttributes = e.privateAttributeNames.map(e => e.startsWith(\"/\") ? Le.literalToReference(e) : e)), t;\n  })(e), t) : \"multi\" === e.kind ? ((e, t) => {\n    const n = {\n        kind: e.kind\n      },\n      r = Object.keys(e);\n    for (const o of r) if (\"kind\" !== o) {\n      const r = a(e[o], t);\n      r && (n[o] = r);\n    }\n    return n;\n  })(e, t) : a(e, t), t;\n};\nconst {\n  getContextKeys: Ae\n} = De;\nvar je = function (e, t, n, r = null, o = null, i = null) {\n  const a = {},\n    c = i || ye(e, n, t),\n    u = S.appendUrlPath(t.eventsUrl, \"/events/bulk/\" + n),\n    l = Ue(t),\n    d = Ce(l),\n    f = t.samplingInterval,\n    g = t.eventCapacity,\n    v = t.flushInterval,\n    p = t.logger;\n  let m,\n    h = [],\n    y = 0,\n    w = !1,\n    b = !1;\n  function k() {\n    return 0 === f || 0 === Math.floor(Math.random() * f);\n  }\n  function E(e) {\n    const t = S.extend({}, e);\n    return \"identify\" === e.kind || \"feature\" === e.kind || \"custom\" === e.kind ? t.context = l.filter(e.context) : (t.contextKeys = Ae(e.context, p), delete t.context), \"feature\" === e.kind && (delete t.trackEvents, delete t.debugEventsUntilDate), t;\n  }\n  function D(e) {\n    h.length < g ? (h.push(e), b = !1) : (b || (b = !0, p.warn(ae.eventCapacityExceeded())), r && r.incrementDroppedEvents());\n  }\n  return a.enqueue = function (e) {\n    if (w) return;\n    let t = !1,\n      n = !1;\n    var r;\n    if (d.summarizeEvent(e), \"feature\" === e.kind ? k() && (t = !!e.trackEvents, n = !!(r = e).debugEventsUntilDate && r.debugEventsUntilDate > y && r.debugEventsUntilDate > new Date().getTime()) : t = k(), t && D(E(e)), n) {\n      const t = S.extend({}, e, {\n        kind: \"debug\"\n      });\n      t.context = l.filter(t.context), delete t.trackEvents, delete t.debugEventsUntilDate, D(t);\n    }\n  }, a.flush = /*#__PURE__*/_asyncToGenerator(function* () {\n    if (w) return Promise.resolve();\n    const e = h;\n    return d.getSummaries().forEach(t => {\n      Object.keys(t.features).length && e.push(t);\n    }), r && r.setEventsInLastBatch(e.length), 0 === e.length ? Promise.resolve() : (h = [], p.debug(ae.debugPostingEvents(e.length)), c.sendEvents(e, u).then(e => {\n      e && (e.serverTime && (y = e.serverTime), s.isHttpErrorRecoverable(e.status) || (w = !0), e.status >= 400 && S.onNextTick(() => {\n        o.maybeReportError(new s.LDUnexpectedResponseError(ae.httpErrorMessage(e.status, \"event posting\", \"some events were dropped\")));\n      }));\n    }));\n  }), a.start = function () {\n    const e = () => {\n      a.flush(), m = setTimeout(e, v);\n    };\n    m = setTimeout(e, v);\n  }, a.stop = function () {\n    clearTimeout(m);\n  }, a;\n};\nvar Re = function (e) {\n  const t = {},\n    n = {};\n  return t.on = function (e, t, r) {\n    n[e] = n[e] || [], n[e] = n[e].concat({\n      handler: t,\n      context: r\n    });\n  }, t.off = function (e, t, r) {\n    if (n[e]) for (let o = 0; o < n[e].length; o++) n[e][o].handler === t && n[e][o].context === r && (n[e] = n[e].slice(0, o).concat(n[e].slice(o + 1)));\n  }, t.emit = function (e) {\n    if (!n[e]) return;\n    const t = n[e].slice(0);\n    for (let e = 0; e < t.length; e++) t[e].handler.apply(t[e].context, Array.prototype.slice.call(arguments, 1));\n  }, t.getEvents = function () {\n    return Object.keys(n);\n  }, t.getEventListenerCount = function (e) {\n    return n[e] ? n[e].length : 0;\n  }, t.maybeReportError = function (t) {\n    t && (n[\"error\"] ? this.emit(\"error\", t) : (e || console).error(t.message));\n  }, t;\n};\nconst Ne = \"ready\",\n  $e = \"initialized\",\n  Ve = \"failed\";\nvar He = function (e) {\n  let t = !1,\n    n = !1,\n    r = null,\n    o = null;\n  const i = new Promise(t => {\n    const n = () => {\n      e.off(Ne, n), t();\n    };\n    e.on(Ne, n);\n  }).catch(() => {});\n  return {\n    getInitializationPromise: () => o || (t ? Promise.resolve() : n ? Promise.reject(r) : (o = new Promise((t, n) => {\n      const r = () => {\n          e.off($e, r), t();\n        },\n        o = t => {\n          e.off(Ve, o), n(t);\n        };\n      e.on($e, r), e.on(Ve, o);\n    }), o)),\n    getReadyPromise: () => i,\n    signalSuccess: () => {\n      t || n || (t = !0, e.emit($e), e.emit(Ne));\n    },\n    signalFailure: o => {\n      t || n || (n = !0, r = o, e.emit(Ve, o), e.emit(Ne)), e.maybeReportError(o);\n    }\n  };\n};\nvar Me = function (e, t, n, r) {\n  const o = {};\n  function i() {\n    let e = \"\";\n    const o = r.getContext();\n    return o && (e = n || S.btoa(JSON.stringify(o))), \"ld:\" + t + \":\" + e;\n  }\n  return o.loadFlags = () => e.get(i()).then(e => {\n    if (null == e) return null;\n    try {\n      let t = JSON.parse(e);\n      if (t) {\n        const e = t.$schema;\n        void 0 === e || e < 1 ? t = S.transformValuesToVersionedValues(t) : delete t.$schema;\n      }\n      return t;\n    } catch (e) {\n      return o.clearFlags().then(() => null);\n    }\n  }), o.saveFlags = t => {\n    const n = S.extend({}, t, {\n      $schema: 1\n    });\n    return e.set(i(), JSON.stringify(n));\n  }, o.clearFlags = () => e.clear(i()), o;\n};\nvar qe = function (e, t) {\n  const n = {};\n  let r = !1;\n  const o = e => {\n    r || (r = !0, t.warn(ae.localStorageUnavailable(e)));\n  };\n  return n.isEnabled = () => !!e, n.get = t => new Promise(n => {\n    e ? e.get(t).then(n).catch(e => {\n      o(e), n(void 0);\n    }) : n(void 0);\n  }), n.set = (t, n) => new Promise(r => {\n    e ? e.set(t, n).then(() => r(!0)).catch(e => {\n      o(e), r(!1);\n    }) : r(!1);\n  }), n.clear = t => new Promise(n => {\n    e ? e.clear(t).then(() => n(!0)).catch(e => {\n      o(e), n(!1);\n    }) : n(!1);\n  }), n;\n};\nconst {\n    appendUrlPath: ze,\n    base64URLEncode: Ke,\n    objectHasOwnProperty: _e\n  } = S,\n  {\n    getLDHeaders: Je,\n    transformHeaders: Be\n  } = ve,\n  {\n    isHttpErrorRecoverable: We\n  } = s;\nvar Ge = function (e, t, n, r) {\n  const o = t.streamUrl,\n    i = t.logger,\n    a = {},\n    s = ze(o, \"/eval/\" + n),\n    c = t.useReport,\n    u = t.evaluationReasons,\n    l = t.streamReconnectDelay,\n    d = Je(e, t);\n  let f,\n    g = !1,\n    v = null,\n    p = null,\n    m = null,\n    h = null,\n    y = null,\n    w = 0;\n  function b() {\n    const e = (t = function () {\n      const e = l * Math.pow(2, w);\n      return e > 3e4 ? 3e4 : e;\n    }(), t - Math.trunc(.5 * Math.random() * t));\n    var t;\n    return w += 1, e;\n  }\n  function k(e) {\n    if (e.status && \"number\" == typeof e.status && !We(e.status)) return x(), i.error(ae.unrecoverableStreamError(e)), void (p && (clearTimeout(p), p = null));\n    const t = b();\n    g || (i.warn(ae.streamError(e, t)), g = !0), O(!1), x(), E(t);\n  }\n  function E(e) {\n    p || (e ? p = setTimeout(D, e) : D());\n  }\n  function D() {\n    let r;\n    p = null;\n    let a = \"\";\n    const l = {\n      headers: d,\n      readTimeoutMillis: 3e5\n    };\n    if (e.eventSourceFactory) {\n      null != h && (a = \"h=\" + h), c ? e.eventSourceAllowsReport ? (r = s, l.method = \"REPORT\", l.headers[\"Content-Type\"] = \"application/json\", l.body = JSON.stringify(m)) : (r = ze(o, \"/ping/\" + n), a = \"\") : r = s + \"/\" + Ke(JSON.stringify(m)), l.headers = Be(l.headers, t), u && (a = a + (a ? \"&\" : \"\") + \"withReasons=true\"), r = r + (a ? \"?\" : \"\") + a, x(), i.info(ae.streamConnecting(r)), f = new Date().getTime(), v = e.eventSourceFactory(r, l);\n      for (const e in y) _e(y, e) && v.addEventListener(e, y[e]);\n      v.onerror = k, v.onopen = () => {\n        w = 0;\n      };\n    }\n  }\n  function x() {\n    v && (i.info(ae.streamClosing()), v.close(), v = null);\n  }\n  function O(e) {\n    f && r && r.recordStreamInit(f, !e, new Date().getTime() - f), f = null;\n  }\n  return a.connect = function (e, t, n) {\n    m = e, h = t, y = {};\n    for (const e in n || {}) y[e] = function (t) {\n      g = !1, O(!0), n[e] && n[e](t);\n    };\n    E();\n  }, a.disconnect = function () {\n    clearTimeout(p), p = null, x();\n  }, a.isConnected = function () {\n    return !!(v && e.eventSourceIsActive && e.eventSourceIsActive(v));\n  }, a;\n};\nvar Xe = function (e) {\n  let t, n, r, o;\n  const i = {\n    addPromise: (i, a) => {\n      t = i, n && n(), n = a, i.then(n => {\n        t === i && (r(n), e && e());\n      }, n => {\n        t === i && (o(n), e && e());\n      });\n    }\n  };\n  return i.resultPromise = new Promise((e, t) => {\n    r = e, o = t;\n  }), i;\n};\nconst {\n    transformHeaders: Qe,\n    getLDHeaders: Ye\n  } = ve,\n  Ze = \"application/json\";\nvar et = function (e, t, n) {\n  const r = t.baseUrl,\n    o = t.useReport,\n    i = t.evaluationReasons,\n    a = t.logger,\n    c = {},\n    u = {};\n  function l(n, r) {\n    if (!e.httpRequest) return new Promise((e, t) => {\n      t(new s.LDFlagFetchError(ae.httpUnavailable()));\n    });\n    const o = r ? \"REPORT\" : \"GET\",\n      i = Ye(e, t);\n    r && (i[\"Content-Type\"] = Ze);\n    let a = u[n];\n    a || (a = Xe(() => {\n      delete u[n];\n    }), u[n] = a);\n    const c = e.httpRequest(o, n, Qe(i, t), r),\n      l = c.promise.then(e => {\n        if (200 === e.status) {\n          if (e.header(\"content-type\") && e.header(\"content-type\").substring(0, 16) === Ze) return JSON.parse(e.body);\n          {\n            const t = ae.invalidContentType(e.header(\"content-type\") || \"\");\n            return Promise.reject(new s.LDFlagFetchError(t));\n          }\n        }\n        return Promise.reject(function (e) {\n          return 404 === e.status ? new s.LDInvalidEnvironmentIdError(ae.environmentNotFound()) : new s.LDFlagFetchError(ae.errorFetchingFlags(e.statusText || String(e.status)));\n        }(e));\n      }, e => Promise.reject(new s.LDFlagFetchError(ae.networkError(e))));\n    return a.addPromise(l, () => {\n      c.cancel && c.cancel();\n    }), a.resultPromise;\n  }\n  return c.fetchJSON = function (e) {\n    return l(S.appendUrlPath(r, e), null);\n  }, c.fetchFlagSettings = function (e, t) {\n    let s,\n      c,\n      u,\n      d = \"\";\n    return o ? (c = [r, \"/sdk/evalx/\", n, \"/context\"].join(\"\"), u = JSON.stringify(e)) : (s = S.base64URLEncode(JSON.stringify(e)), c = [r, \"/sdk/evalx/\", n, \"/contexts/\", s].join(\"\")), t && (d = \"h=\" + t), i && (d = d + (d ? \"&\" : \"\") + \"withReasons=true\"), c = c + (d ? \"?\" : \"\") + d, a.debug(ae.debugPolling(c)), l(c, u);\n  }, c;\n};\nvar tt = function (e, t) {\n  const n = {};\n  let r;\n  return n.setContext = function (e) {\n    r = S.sanitizeContext(e), r && t && t(S.clone(r));\n  }, n.getContext = function () {\n    return r ? S.clone(r) : null;\n  }, e && n.setContext(e), n;\n};\nconst {\n    v1: nt\n  } = te,\n  {\n    getContextKinds: rt\n  } = De;\nvar ot = function (e) {\n  function t(e) {\n    return null == e || \"user\" === e ? \"ld:$anonUserId\" : `ld:$contextKey:${e}`;\n  }\n  function n(n, r) {\n    return null !== r.key && void 0 !== r.key ? (r.key = r.key.toString(), Promise.resolve(r)) : r.anonymous ? function (n) {\n      return e.get(t(n));\n    }(n).then(o => {\n      if (o) return r.key = o, r;\n      {\n        const o = nt();\n        return r.key = o, function (n, r) {\n          return e.set(t(r), n);\n        }(o, n).then(() => r);\n      }\n    }) : Promise.reject(new s.LDInvalidUserError(ae.invalidContext()));\n  }\n  this.processContext = e => {\n    if (!e) return Promise.reject(new s.LDInvalidUserError(ae.contextNotSpecified()));\n    const t = S.clone(e);\n    if (\"multi\" === e.kind) {\n      const e = rt(t);\n      return Promise.all(e.map(e => n(e, t[e]))).then(() => t);\n    }\n    return n(e.kind, t);\n  };\n};\nconst {\n    v1: it\n  } = te,\n  {\n    baseOptionDefs: at\n  } = fe,\n  {\n    appendUrlPath: st\n  } = S;\nvar ct = {\n  DiagnosticId: function (e) {\n    const t = {\n      diagnosticId: it()\n    };\n    return e && (t.sdkKeySuffix = e.length > 6 ? e.substring(e.length - 6) : e), t;\n  },\n  DiagnosticsAccumulator: function (e) {\n    let t, n, r, o;\n    function i(e) {\n      t = e, n = 0, r = 0, o = [];\n    }\n    return i(e), {\n      getProps: () => ({\n        dataSinceDate: t,\n        droppedEvents: n,\n        eventsInLastBatch: r,\n        streamInits: o\n      }),\n      setProps: e => {\n        t = e.dataSinceDate, n = e.droppedEvents || 0, r = e.eventsInLastBatch || 0, o = e.streamInits || [];\n      },\n      incrementDroppedEvents: () => {\n        n++;\n      },\n      setEventsInLastBatch: e => {\n        r = e;\n      },\n      recordStreamInit: (e, t, n) => {\n        const r = {\n          timestamp: e,\n          failed: t,\n          durationMillis: n\n        };\n        o.push(r);\n      },\n      reset: i\n    };\n  },\n  DiagnosticsManager: function (e, t, n, r, o, i, a) {\n    const s = !!e.diagnosticUseCombinedEvent,\n      c = \"ld:\" + o + \":$diagnostics\",\n      u = st(i.eventsUrl, \"/events/diagnostic/\" + o),\n      l = i.diagnosticRecordingInterval,\n      d = n;\n    let f,\n      g,\n      v = !!i.streaming;\n    const p = {};\n    function m() {\n      return {\n        sdk: w(),\n        configuration: b(),\n        platform: e.diagnosticPlatformData\n      };\n    }\n    function h(e) {\n      i.logger && i.logger.debug(ae.debugPostingDiagnosticEvent(e)), r.sendEvents(e, u, !0).then(() => {}).catch(() => {});\n    }\n    function y() {\n      h(function () {\n        const e = new Date().getTime();\n        let t = {\n          kind: s ? \"diagnostic-combined\" : \"diagnostic\",\n          id: a,\n          creationDate: e,\n          ...d.getProps()\n        };\n        return s && (t = {\n          ...t,\n          ...m()\n        }), d.reset(e), t;\n      }()), g = setTimeout(y, l), f = new Date().getTime(), s && function () {\n        if (t.isEnabled()) {\n          const e = {\n            ...d.getProps()\n          };\n          t.set(c, JSON.stringify(e));\n        }\n      }();\n    }\n    function w() {\n      const t = {\n        ...e.diagnosticSdkData\n      };\n      return i.wrapperName && (t.wrapperName = i.wrapperName), i.wrapperVersion && (t.wrapperVersion = i.wrapperVersion), t;\n    }\n    function b() {\n      return {\n        customBaseURI: i.baseUrl !== at.baseUrl.default,\n        customStreamURI: i.streamUrl !== at.streamUrl.default,\n        customEventsURI: i.eventsUrl !== at.eventsUrl.default,\n        eventsCapacity: i.eventCapacity,\n        eventsFlushIntervalMillis: i.flushInterval,\n        reconnectTimeMillis: i.streamReconnectDelay,\n        streamingDisabled: !v,\n        allAttributesPrivate: !!i.allAttributesPrivate,\n        diagnosticRecordingIntervalMillis: i.diagnosticRecordingInterval,\n        usingSecureMode: !!i.hash,\n        bootstrapMode: !!i.bootstrap,\n        fetchGoalsDisabled: !i.fetchGoals,\n        sendEventsOnlyForVariation: !!i.sendEventsOnlyForVariation\n      };\n    }\n    return p.start = () => {\n      s ? function (e) {\n        if (!t.isEnabled()) return e(!1);\n        t.get(c).then(t => {\n          if (t) try {\n            const e = JSON.parse(t);\n            d.setProps(e), f = e.dataSinceDate;\n          } catch (e) {}\n          e(!0);\n        }).catch(() => {\n          e(!1);\n        });\n      }(e => {\n        if (e) {\n          const e = (f || 0) + l,\n            t = new Date().getTime();\n          t >= e ? y() : g = setTimeout(y, e - t);\n        } else 0 === Math.floor(4 * Math.random()) ? y() : g = setTimeout(y, l);\n      }) : (h({\n        kind: \"diagnostic-init\",\n        id: a,\n        creationDate: d.getProps().dataSinceDate,\n        ...m()\n      }), g = setTimeout(y, l));\n    }, p.stop = () => {\n      g && clearTimeout(g);\n    }, p.setStreaming = e => {\n      v = e;\n    }, p;\n  }\n};\nvar ut = function (e, t) {\n  let n = !1;\n  const r = {\n    type: e.type,\n    name: e.name,\n    synchronous: e.synchronous,\n    method: (...o) => {\n      try {\n        e.method(...o);\n      } catch {\n        n || (n = !0, t.warn(ae.inspectorMethodError(r.type, r.name)));\n      }\n    }\n  };\n  return r;\n};\nconst {\n    onNextTick: lt\n  } = S,\n  dt = {\n    flagUsed: \"flag-used\",\n    flagDetailsChanged: \"flag-details-changed\",\n    flagDetailChanged: \"flag-detail-changed\",\n    clientIdentityChanged: \"client-identity-changed\"\n  };\nObject.freeze(dt);\nvar ft = {\n  InspectorTypes: dt,\n  InspectorManager: function (e, t) {\n    const n = {},\n      r = {\n        [dt.flagUsed]: [],\n        [dt.flagDetailsChanged]: [],\n        [dt.flagDetailChanged]: [],\n        [dt.clientIdentityChanged]: []\n      },\n      o = {\n        [dt.flagUsed]: [],\n        [dt.flagDetailsChanged]: [],\n        [dt.flagDetailChanged]: [],\n        [dt.clientIdentityChanged]: []\n      },\n      i = e && e.map(e => ut(e, t));\n    return i && i.forEach(e => {\n      Object.prototype.hasOwnProperty.call(r, e.type) && !e.synchronous ? r[e.type].push(e) : Object.prototype.hasOwnProperty.call(o, e.type) && e.synchronous ? o[e.type].push(e) : t.warn(ae.invalidInspector(e.type, e.name));\n    }), n.hasListeners = e => r[e] && r[e].length || o[e] && o[e].length, n.onFlagUsed = (e, t, n) => {\n      const i = dt.flagUsed;\n      o[i].length && o[i].forEach(r => r.method(e, t, n)), r[i].length && lt(() => {\n        r[i].forEach(r => r.method(e, t, n));\n      });\n    }, n.onFlags = e => {\n      const t = dt.flagDetailsChanged;\n      o[t].length && o[t].forEach(t => t.method(e)), r[t].length && lt(() => {\n        r[t].forEach(t => t.method(e));\n      });\n    }, n.onFlagChanged = (e, t) => {\n      const n = dt.flagDetailChanged;\n      o[n].length && o[n].forEach(n => n.method(e, t)), r[n].length && lt(() => {\n        r[n].forEach(n => n.method(e, t));\n      });\n    }, n.onIdentityChanged = e => {\n      const t = dt.clientIdentityChanged;\n      o[t].length && o[t].forEach(t => t.method(e)), r[t].length && lt(() => {\n        r[t].forEach(t => t.method(e));\n      });\n    }, n;\n  }\n};\nconst {\n  LDTimeoutError: gt\n} = s;\nvar vt = function (e, t) {\n  return new Promise((n, r) => {\n    setTimeout(() => {\n      r(new gt(`${t} timed out after ${e} seconds.`));\n    }, 1e3 * e);\n  });\n};\nconst pt = \"unknown hook\";\nfunction mt(e, t, n, r, o) {\n  try {\n    return r();\n  } catch (r) {\n    return e?.error(`An error was encountered in \"${t}\" of the \"${n}\" hook: ${r}`), o;\n  }\n}\nfunction ht(e, t) {\n  try {\n    return t.getMetadata().name || pt;\n  } catch {\n    return e.error(\"Exception thrown getting metadata for hook. Unable to get hook name.\"), pt;\n  }\n}\nvar yt = function (e, t) {\n  const n = t ? [...t] : [];\n  return {\n    withEvaluation: function (t, r, o, i) {\n      if (0 === n.length) return i();\n      const a = [...n],\n        s = {\n          flagKey: t,\n          context: r,\n          defaultValue: o\n        },\n        c = function (e, t, n) {\n          return t.map(t => mt(e, \"beforeEvaluation\", ht(e, t), () => t?.beforeEvaluation?.(n, {}) ?? {}, {}));\n        }(e, a, s),\n        u = i();\n      return function (e, t, n, r, o) {\n        for (let i = t.length - 1; i >= 0; i -= 1) {\n          const a = t[i],\n            s = r[i];\n          mt(e, \"afterEvaluation\", ht(e, a), () => a?.afterEvaluation?.(n, s, o) ?? {}, {});\n        }\n      }(e, a, s, c, u), u;\n    },\n    identify: function (t, r) {\n      const o = [...n],\n        i = {\n          context: t,\n          timeout: r\n        },\n        a = function (e, t, n) {\n          return t.map(t => mt(e, \"beforeIdentify\", ht(e, t), () => t?.beforeIdentify?.(n, {}) ?? {}, {}));\n        }(e, o, i);\n      return t => {\n        !function (e, t, n, r, o) {\n          for (let i = t.length - 1; i >= 0; i -= 1) {\n            const a = t[i],\n              s = r[i];\n            mt(e, \"afterIdentify\", ht(e, a), () => a?.afterIdentify?.(n, s, o) ?? {}, {});\n          }\n        }(e, o, i, a, t);\n      };\n    },\n    addHook: function (e) {\n      n.push(e);\n    },\n    afterTrack: function (t) {\n      if (0 === n.length) return;\n      const r = [...n];\n      !function (e, t, n) {\n        for (let r = t.length - 1; r >= 0; r -= 1) {\n          const o = t[r];\n          mt(e, \"afterTrack\", ht(e, o), () => o?.afterTrack?.(n), void 0);\n        }\n      }(e, r, t);\n    }\n  };\n};\nvar wt = function () {\n  let e,\n    t = {};\n  function n(n) {\n    return e && S.objectHasOwnProperty(e, n) && e[n] ? e[n] : t && S.objectHasOwnProperty(t, n) && t[n] && !t[n].deleted ? t[n] : null;\n  }\n  return {\n    clearAllOverrides: function () {\n      if (!e) return {};\n      const t = {\n        ...e\n      };\n      return e = void 0, t;\n    },\n    get: n,\n    getFlagOverrides: function () {\n      return e || {};\n    },\n    getFlags: function () {\n      return t;\n    },\n    getFlagsWithOverrides: function () {\n      const r = {};\n      for (const e in t) {\n        const t = n(e);\n        t && (r[e] = t);\n      }\n      if (e) for (const t in e) {\n        const e = n(t);\n        e && (r[t] = e);\n      }\n      return r;\n    },\n    removeOverride: function (t) {\n      e && e[t] && (delete e[t], 0 === Object.keys(e).length && (e = void 0));\n    },\n    setFlags: function (e) {\n      t = {\n        ...e\n      };\n    },\n    setOverride: function (t, n) {\n      e || (e = {}), e[t] = {\n        value: n\n      };\n    }\n  };\n};\nconst bt = \"unknown plugin\";\nfunction kt(e, t) {\n  try {\n    return t.getMetadata().name || bt;\n  } catch (t) {\n    return e.error(\"Exception thrown getting metadata for plugin. Unable to get plugin name.\"), bt;\n  }\n}\nvar Et = {\n  getPluginHooks: function (e, t, n) {\n    const r = [];\n    return n.forEach(n => {\n      try {\n        const o = n.getHooks?.(t);\n        void 0 === o ? e.error(`Plugin ${kt(e, n)} returned undefined from getHooks.`) : o && o.length > 0 && r.push(...o);\n      } catch (t) {\n        e.error(`Exception thrown getting hooks for plugin ${kt(e, n)}. Unable to get hooks.`);\n      }\n    }), r;\n  },\n  registerPlugins: function (e, t, n, r) {\n    r.forEach(r => {\n      try {\n        r.register(n, t);\n      } catch (t) {\n        e.error(`Exception thrown registering plugin ${kt(e, r)}.`);\n      }\n    });\n  },\n  registerPluginsForDebugOverride: function (e, t, n) {\n    n.forEach(n => {\n      try {\n        n.registerDebug?.(t);\n      } catch (t) {\n        e.error(`Exception thrown registering debug override with plugin ${kt(e, n)}.`);\n      }\n    });\n  },\n  createPluginEnvironment: function (e, t, n) {\n    const r = {};\n    e.userAgent && (r.name = e.userAgent), e.version && (r.version = e.version), n.wrapperName && (r.wrapperName = n.wrapperName), n.wrapperVersion && (r.wrapperVersion = n.wrapperVersion);\n    const o = {};\n    n.application && (n.application.name && (o.name = n.application.name), n.application.version && (o.version = n.application.version));\n    const i = {\n      sdk: r,\n      clientSideId: t\n    };\n    return Object.keys(o).length > 0 && (i.application = o), i;\n  }\n};\nconst {\n    commonBasicLogger: Dt\n  } = re,\n  {\n    checkContext: xt,\n    getContextKeys: Ot\n  } = De,\n  {\n    InspectorTypes: Ct,\n    InspectorManager: Pt\n  } = ft,\n  {\n    getPluginHooks: St,\n    registerPlugins: It,\n    registerPluginsForDebugOverride: Tt,\n    createPluginEnvironment: Ft\n  } = Et,\n  Lt = \"change\",\n  Ut = \"internal-change\";\nvar At = {\n    initialize: function (e, t, n, r, o) {\n      const i = function () {\n          if (n && n.logger) return n.logger;\n          return o && o.logger && o.logger.default || Dt(\"warn\");\n        }(),\n        a = Re(i),\n        c = He(a),\n        u = fe.validate(n, a, o, i),\n        l = Pt(u.inspectors, i),\n        d = u.sendEvents;\n      let f = e,\n        g = u.hash;\n      const v = [...u.plugins],\n        p = Ft(r, e, u),\n        m = St(i, p, v),\n        h = yt(i, [...u.hooks, ...m]),\n        y = qe(r.localStorage, i),\n        w = ye(r, f, u),\n        b = u.sendEvents && !u.diagnosticOptOut,\n        k = b ? ct.DiagnosticId(f) : null,\n        E = b ? ct.DiagnosticsAccumulator(new Date().getTime()) : null,\n        D = b ? ct.DiagnosticsManager(r, y, E, w, f, u, k) : null,\n        x = Ge(r, u, f, E),\n        O = u.eventProcessor || je(r, u, f, E, a, w),\n        C = et(r, u, f),\n        P = wt();\n      let I,\n        T,\n        F,\n        L = u.streaming,\n        U = !1,\n        A = !1,\n        j = !0;\n      const R = u.stateProvider,\n        N = tt(null, function (e) {\n          (function (e) {\n            if (R) return;\n            e && H({\n              kind: \"identify\",\n              context: e,\n              creationDate: new Date().getTime()\n            });\n          })(e), l.hasListeners(Ct.clientIdentityChanged) && l.onIdentityChanged(N.getContext());\n        }),\n        $ = new ot(y),\n        V = y.isEnabled() ? Me(y, f, g, N) : null;\n      function H(e) {\n        f && (R && R.enqueueEvent && R.enqueueEvent(e) || (e.context ? (j = !1, !d || A || r.isDoNotTrack() || (i.debug(ae.debugEnqueueingEvent(e.kind)), O.enqueue(e))) : j && (i.warn(ae.eventWithoutContext()), j = !1)));\n      }\n      function M(e, t) {\n        l.hasListeners(Ct.flagDetailChanged) && l.onFlagChanged(e.key, J(t));\n      }\n      function q() {\n        l.hasListeners(Ct.flagDetailsChanged) && l.onFlags(Object.entries(P.getFlagsWithOverrides()).map(([e, t]) => ({\n          key: e,\n          detail: J(t)\n        })).reduce((e, t) => (e[t.key] = t.detail, e), {}));\n      }\n      function z(e, t, n, r) {\n        const o = N.getContext(),\n          i = new Date(),\n          a = {\n            kind: \"feature\",\n            key: e,\n            context: o,\n            value: t ? t.value : null,\n            variation: t ? t.variationIndex : null,\n            default: n,\n            creationDate: i.getTime()\n          },\n          s = P.getFlags()[e];\n        s && (a.version = s.flagVersion ? s.flagVersion : s.version, a.trackEvents = s.trackEvents, a.debugEventsUntilDate = s.debugEventsUntilDate), (r || s && s.trackReason) && t && (a.reason = t.reason), H(a);\n      }\n      function K(e) {\n        return xt(e, !1) ? Promise.resolve(e) : Promise.reject(new s.LDInvalidUserError(ae.invalidContext()));\n      }\n      function _(e, t, n, r, o, i) {\n        let a;\n        const s = P.get(e);\n        return s ? (a = J(s), null !== s.value && void 0 !== s.value || (a.value = t)) : a = {\n          value: t,\n          variationIndex: null,\n          reason: {\n            kind: \"ERROR\",\n            errorKind: \"FLAG_NOT_FOUND\"\n          }\n        }, n && (o || s?.prerequisites?.forEach(e => {\n          _(e, void 0, n, !1, !1, !1);\n        }), z(e, a, t, r)), !o && i && function (e, t) {\n          l.hasListeners(Ct.flagUsed) && l.onFlagUsed(e, t, N.getContext());\n        }(e, a), a;\n      }\n      function J(e) {\n        return {\n          value: e.value,\n          variationIndex: void 0 === e.variation ? null : e.variation,\n          reason: e.reason || null\n        };\n      }\n      function B() {\n        if (T = !0, !N.getContext()) return;\n        const e = e => {\n          try {\n            return JSON.parse(e);\n          } catch (e) {\n            return void a.maybeReportError(new s.LDInvalidDataError(ae.invalidData()));\n          }\n        };\n        x.connect(N.getContext(), g, {\n          ping: function () {\n            i.debug(ae.debugStreamPing());\n            const e = N.getContext();\n            C.fetchFlagSettings(e, g).then(t => {\n              S.deepEquals(e, N.getContext()) && G(t || {});\n            }).catch(e => {\n              a.maybeReportError(new s.LDFlagFetchError(ae.errorFetchingFlags(e)));\n            });\n          },\n          put: function (t) {\n            const n = e(t.data);\n            n && (i.debug(ae.debugStreamPut()), G(n));\n          },\n          patch: function (t) {\n            const n = e(t.data);\n            if (!n) return;\n            const r = P.getFlags(),\n              o = r[n.key];\n            if (!o || !o.version || !n.version || o.version < n.version) {\n              i.debug(ae.debugStreamPatch(n.key));\n              const e = {},\n                t = S.extend({}, n);\n              delete t.key, r[n.key] = t, P.setFlags(r);\n              const a = J(t);\n              e[n.key] = o ? {\n                previous: o.value,\n                current: a\n              } : {\n                current: a\n              }, M(n, t), X(e);\n            } else i.debug(ae.debugStreamPatchIgnored(n.key));\n          },\n          delete: function (t) {\n            const n = e(t.data);\n            if (!n) return;\n            const r = P.getFlags();\n            if (!r[n.key] || r[n.key].version < n.version) {\n              i.debug(ae.debugStreamDelete(n.key));\n              const e = {};\n              r[n.key] && !r[n.key].deleted && (e[n.key] = {\n                previous: r[n.key].value\n              }), r[n.key] = {\n                version: n.version,\n                deleted: !0\n              }, P.setFlags(r), M(n, r[n.key]), X(e);\n            } else i.debug(ae.debugStreamDeleteIgnored(n.key));\n          }\n        });\n      }\n      function W() {\n        T && (x.disconnect(), T = !1);\n      }\n      function G(e) {\n        const t = {};\n        if (!e) return Promise.resolve();\n        const n = P.getFlags();\n        for (const r in n) S.objectHasOwnProperty(n, r) && n[r] && (e[r] && !S.deepEquals(e[r].value, n[r].value) ? t[r] = {\n          previous: n[r].value,\n          current: J(e[r])\n        } : e[r] && !e[r].deleted || (t[r] = {\n          previous: n[r].value\n        }));\n        for (const r in e) S.objectHasOwnProperty(e, r) && e[r] && (!n[r] || n[r].deleted) && (t[r] = {\n          current: J(e[r])\n        });\n        return P.setFlags({\n          ...e\n        }), q(), X(t).catch(() => {});\n      }\n      function X(e) {\n        const t = Object.keys(e);\n        if (t.length > 0) {\n          const n = {};\n          t.forEach(t => {\n            const r = e[t].current,\n              o = r ? r.value : void 0,\n              i = e[t].previous;\n            a.emit(Lt + \":\" + t, o, i), n[t] = r ? {\n              current: o,\n              previous: i\n            } : {\n              previous: i\n            };\n          }), a.emit(Lt, n), a.emit(Ut, P.getFlagsWithOverrides()), u.sendEventsOnlyForVariation || R || t.forEach(t => {\n            z(t, e[t].current);\n          });\n        }\n        return I && V ? V.saveFlags(P.getFlags()) : Promise.resolve();\n      }\n      function Q() {\n        const e = L || F && void 0 === L;\n        e && !T ? B() : !e && T && W(), D && D.setStreaming(e);\n      }\n      function Y(e) {\n        return e === Lt || e.substr(0, 7) === Lt + \":\";\n      }\n      if (\"string\" == typeof u.bootstrap && \"LOCALSTORAGE\" === u.bootstrap.toUpperCase() && (V ? I = !0 : i.warn(ae.localStorageUnavailable())), \"object\" == typeof u.bootstrap && P.setFlags(function (e) {\n        const t = Object.keys(e),\n          n = \"$flagsState\",\n          r = \"$valid\",\n          o = e[n];\n        !o && t.length && i.warn(ae.bootstrapOldFormat()), !1 === e[r] && i.warn(ae.bootstrapInvalid());\n        const a = {};\n        return t.forEach(t => {\n          if (t !== n && t !== r) {\n            let n = {\n              value: e[t]\n            };\n            o && o[t] ? n = S.extend(n, o[t]) : n.version = 0, a[t] = n;\n          }\n        }), a;\n      }(u.bootstrap)), R) {\n        const e = R.getInitialState();\n        e ? Z(e) : R.on(\"init\", Z), R.on(\"update\", function (e) {\n          e.context && N.setContext(e.context);\n          e.flags && G(e.flags);\n        });\n      } else (function () {\n        if (!e) return Promise.reject(new s.LDInvalidEnvironmentIdError(ae.environmentNotSpecified()));\n        let n;\n        return $.processContext(t).then(K).then(e => (n = S.once(h.identify(e, void 0)), e)).then(e => (n?.({\n          status: \"completed\"\n        }), N.setContext(e), \"object\" == typeof u.bootstrap ? ee() : I ? V.loadFlags().then(e => null == e ? (P.setFlags({}), C.fetchFlagSettings(N.getContext(), g).then(e => G(e || {})).then(ee).catch(e => {\n          te(new s.LDFlagFetchError(ae.errorFetchingFlags(e)));\n        })) : (P.setFlags(e), S.onNextTick(ee), C.fetchFlagSettings(N.getContext(), g).then(e => G(e)).catch(e => a.maybeReportError(e)))) : C.fetchFlagSettings(N.getContext(), g).then(e => {\n          P.setFlags(e || {}), q(), ee();\n        }).catch(e => {\n          P.setFlags({}), te(e);\n        }))).catch(e => {\n          throw n?.({\n            status: \"error\"\n          }), e;\n        });\n      })().catch(te);\n      function Z(e) {\n        f = e.environment, N.setContext(e.context), P.setFlags({\n          ...e.flags\n        }), S.onNextTick(ee);\n      }\n      function ee() {\n        i.info(ae.clientInitialized()), U = !0, Q(), c.signalSuccess();\n      }\n      function te(e) {\n        c.signalFailure(e);\n      }\n      const ne = {\n        waitForInitialization: function (e = void 0) {\n          if (null != e) {\n            if (\"number\" == typeof e) return function (e) {\n              e > 5 && i.warn(\"The waitForInitialization function was called with a timeout greater than 5 seconds. We recommend a timeout of 5 seconds or less.\");\n              const t = c.getInitializationPromise(),\n                n = vt(e, \"waitForInitialization\");\n              return Promise.race([n, t]).catch(e => {\n                throw e instanceof s.LDTimeoutError && i.error(`waitForInitialization error: ${e}`), e;\n              });\n            }(e);\n            i.warn(\"The waitForInitialization method was provided with a non-numeric timeout.\");\n          }\n          return i.warn(\"The waitForInitialization function was called without a timeout specified. In a future version a default timeout will be applied.\"), c.getInitializationPromise();\n        },\n        waitUntilReady: () => c.getReadyPromise(),\n        identify: function (e, t, n) {\n          if (A) return S.wrapPromiseCallback(Promise.resolve({}), n);\n          if (R) return i.warn(ae.identifyDisabled()), S.wrapPromiseCallback(Promise.resolve(S.transformVersionedValuesToValues(P.getFlagsWithOverrides())), n);\n          let r;\n          const o = I && V ? V.clearFlags() : Promise.resolve();\n          return S.wrapPromiseCallback(o.then(() => $.processContext(e)).then(K).then(e => (r = S.once(h.identify(e, void 0)), e)).then(e => C.fetchFlagSettings(e, t).then(n => {\n            const r = S.transformVersionedValuesToValues(n);\n            return N.setContext(e), g = t, n ? G(n).then(() => r) : r;\n          })).then(e => (r?.({\n            status: \"completed\"\n          }), T && B(), e)).catch(e => (r?.({\n            status: \"error\"\n          }), a.maybeReportError(e), Promise.reject(e))), n);\n        },\n        getContext: function () {\n          return N.getContext();\n        },\n        variation: function (e, t) {\n          const {\n            value: n\n          } = h.withEvaluation(e, N.getContext(), t, () => _(e, t, !0, !1, !1, !0));\n          return n;\n        },\n        variationDetail: function (e, t) {\n          return h.withEvaluation(e, N.getContext(), t, () => _(e, t, !0, !0, !1, !0));\n        },\n        track: function (e, t, n) {\n          if (\"string\" != typeof e) return void a.maybeReportError(new s.LDInvalidEventKeyError(ae.unknownCustomEventKey(e)));\n          void 0 !== n && \"number\" != typeof n && i.warn(ae.invalidMetricValue(typeof n)), r.customEventFilter && !r.customEventFilter(e) && i.warn(ae.unknownCustomEventKey(e));\n          const o = N.getContext(),\n            c = {\n              kind: \"custom\",\n              key: e,\n              context: o,\n              url: r.getCurrentUrl(),\n              creationDate: new Date().getTime()\n            };\n          o && o.anonymous && (c.contextKind = o.anonymous ? \"anonymousUser\" : \"user\"), null != t && (c.data = t), null != n && (c.metricValue = n), H(c), h.afterTrack({\n            context: o,\n            key: e,\n            data: t,\n            metricValue: n\n          });\n        },\n        on: function (e, t, n) {\n          Y(e) ? (F = !0, U && Q(), a.on(e, t, n)) : a.on(...arguments);\n        },\n        off: function (e) {\n          if (a.off(...arguments), Y(e)) {\n            let e = !1;\n            a.getEvents().forEach(t => {\n              Y(t) && a.getEventListenerCount(t) > 0 && (e = !0);\n            }), e || (F = !1, T && void 0 === L && W());\n          }\n        },\n        setStreaming: function (e) {\n          const t = null === e ? void 0 : e;\n          t !== L && (L = t, Q());\n        },\n        flush: function (e) {\n          return S.wrapPromiseCallback(d ? O.flush() : Promise.resolve(), e);\n        },\n        allFlags: function () {\n          const e = {},\n            t = P.getFlagsWithOverrides();\n          if (!t) return e;\n          for (const n in t) e[n] = _(n, null, !u.sendEventsOnlyForVariation, !1, !0, !1).value;\n          return e;\n        },\n        close: function (e) {\n          if (A) return S.wrapPromiseCallback(Promise.resolve(), e);\n          const t = () => {\n              A = !0, P.setFlags({});\n            },\n            n = Promise.resolve().then(() => {\n              if (W(), D && D.stop(), d) return O.stop(), O.flush();\n            }).then(t).catch(t);\n          return S.wrapPromiseCallback(n, e);\n        },\n        addHook: function (e) {\n          h.addHook(e);\n        }\n      };\n      It(i, p, ne, v);\n      const re = {\n        setOverride: function (e, t) {\n          const n = {},\n            r = P.get(e),\n            o = r ? r.value : null;\n          if (o === t) return void i.debug(`setOverride: No change needed for ${e}, value already ${t}`);\n          P.setOverride(e, t);\n          const a = P.get(e),\n            s = J(a);\n          n[e] = {\n            previous: o,\n            current: s\n          }, M({\n            key: e\n          }, a), X(n);\n        },\n        removeOverride: function (e) {\n          const t = P.getFlagOverrides();\n          if (!t[e]) return;\n          const n = {},\n            r = t[e],\n            o = P.getFlags()[e];\n          n[e] = {\n            previous: r.value,\n            current: o ? J(o) : void 0\n          }, P.removeOverride(e), M({\n            key: e\n          }, o), X(n);\n        },\n        clearAllOverrides: function () {\n          const e = P.getFlagOverrides();\n          if (0 === Object.keys(e).length) return;\n          const t = {},\n            n = P.getFlags();\n          Object.keys(e).forEach(r => {\n            const o = e[r],\n              i = n[r];\n            t[r] = {\n              previous: o.value,\n              current: i ? J(i) : void 0\n            };\n          }), P.clearAllOverrides(), Object.keys(t).length > 0 && X(t);\n        },\n        getAllOverrides: function () {\n          const e = P.getFlagOverrides();\n          if (!e) return {};\n          const t = {};\n          return Object.keys(e).forEach(n => {\n            const r = e[n];\n            r && (t[n] = r.value);\n          }), t;\n        }\n      };\n      return Tt(i, re, v), {\n        client: ne,\n        options: u,\n        emitter: a,\n        ident: N,\n        logger: i,\n        requestor: C,\n        start: function () {\n          d && (D && D.start(), O.start());\n        },\n        enqueueEvent: H,\n        getFlagsInternal: function () {\n          return P.getFlagsWithOverrides();\n        },\n        getEnvironmentId: () => f,\n        internalChangeEventName: Ut\n      };\n    },\n    commonBasicLogger: Dt,\n    errors: s,\n    messages: ae,\n    utils: S,\n    getContextKeys: Ot\n  },\n  jt = At.initialize,\n  Rt = At.errors,\n  Nt = At.messages;\nfunction $t(e, t, n) {\n  return (t = function (e) {\n    var t = function (e, t) {\n      if (\"object\" != typeof e || !e) return e;\n      var n = e[Symbol.toPrimitive];\n      if (void 0 !== n) {\n        var r = n.call(e, t || \"default\");\n        if (\"object\" != typeof r) return r;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n      }\n      return (\"string\" === t ? String : Number)(e);\n    }(e, \"string\");\n    return \"symbol\" == typeof t ? t : t + \"\";\n  }(t)) in e ? Object.defineProperty(e, t, {\n    value: n,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[t] = n, e;\n}\nfunction Vt(e, t) {\n  var n = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(e);\n    t && (r = r.filter(function (t) {\n      return Object.getOwnPropertyDescriptor(e, t).enumerable;\n    })), n.push.apply(n, r);\n  }\n  return n;\n}\nfunction Ht(e) {\n  for (var t = 1; t < arguments.length; t++) {\n    var n = null != arguments[t] ? arguments[t] : {};\n    t % 2 ? Vt(Object(n), !0).forEach(function (t) {\n      $t(e, t, n[t]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vt(Object(n)).forEach(function (t) {\n      Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t));\n    });\n  }\n  return e;\n}\nvar Mt = At.commonBasicLogger;\nvar qt = function (e) {\n  return Mt(Ht({\n    destination: console.log\n  }, e));\n};\nvar zt = {\n  promise: Promise.resolve({\n    status: 200,\n    header: function () {\n      return null;\n    },\n    body: null\n  })\n};\nfunction Kt(e, t, n, r, o) {\n  if (o && !function () {\n    var e = window.navigator && window.navigator.userAgent;\n    if (e) {\n      var t = e.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n      if (t) return parseInt(t[2], 10) < 73;\n    }\n    return !0;\n  }()) return zt;\n  var i = new window.XMLHttpRequest();\n  for (var a in i.open(e, t, !o), n || {}) Object.prototype.hasOwnProperty.call(n, a) && i.setRequestHeader(a, n[a]);\n  if (o) {\n    try {\n      i.send(r);\n    } catch (e) {}\n    return zt;\n  }\n  var s,\n    c = new Promise(function (e, t) {\n      i.addEventListener(\"load\", function () {\n        s || e({\n          status: i.status,\n          header: function (e) {\n            return i.getResponseHeader(e);\n          },\n          body: i.responseText\n        });\n      }), i.addEventListener(\"error\", function () {\n        s || t(new Error());\n      }), i.send(r);\n    });\n  return {\n    promise: c,\n    cancel: function () {\n      s = !0, i.abort();\n    }\n  };\n}\nvar _t = e => {\n  if (\"string\" != typeof e) throw new TypeError(\"Expected a string\");\n  return e.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n};\nfunction Jt(e, t, n, r) {\n  var o,\n    i,\n    a = ((\"substring\" === e.kind || \"regex\" === e.kind) && r.includes(\"/\") ? t : t.replace(r, \"\")).replace(n, \"\");\n  switch (e.kind) {\n    case \"exact\":\n      i = t, o = new RegExp(\"^\" + _t(e.url) + \"/?$\");\n      break;\n    case \"canonical\":\n      i = a, o = new RegExp(\"^\" + _t(e.url) + \"/?$\");\n      break;\n    case \"substring\":\n      i = a, o = new RegExp(\".*\" + _t(e.substring) + \".*$\");\n      break;\n    case \"regex\":\n      i = a, o = new RegExp(e.pattern);\n      break;\n    default:\n      return !1;\n  }\n  return o.test(i);\n}\nfunction Bt(e, t) {\n  for (var n = {}, r = null, o = [], i = 0; i < e.length; i++) for (var a = e[i], s = a.urls || [], c = 0; c < s.length; c++) if (Jt(s[c], window.location.href, window.location.search, window.location.hash)) {\n    \"pageview\" === a.kind ? t(\"pageview\", a) : (o.push(a), t(\"click_pageview\", a));\n    break;\n  }\n  return o.length > 0 && (r = function (e) {\n    for (var n = function (e, t) {\n        for (var n = [], r = 0; r < t.length; r++) for (var o = e.target, i = t[r], a = i.selector, s = document.querySelectorAll(a); o && s.length > 0;) {\n          for (var c = 0; c < s.length; c++) o === s[c] && n.push(i);\n          o = o.parentNode;\n        }\n        return n;\n      }(e, o), r = 0; r < n.length; r++) t(\"click\", n[r]);\n  }, document.addEventListener(\"click\", r)), n.dispose = function () {\n    document.removeEventListener(\"click\", r);\n  }, n;\n}\nfunction Wt(e, t) {\n  var n, r;\n  function o() {\n    r && r.dispose(), n && n.length && (r = Bt(n, i));\n  }\n  function i(t, n) {\n    var r = e.ident.getContext(),\n      o = {\n        kind: t,\n        key: n.key,\n        data: null,\n        url: window.location.href,\n        creationDate: new Date().getTime(),\n        context: r\n      };\n    return \"click\" === t && (o.selector = n.selector), e.enqueueEvent(o);\n  }\n  return e.requestor.fetchJSON(\"/sdk/goals/\" + e.getEnvironmentId()).then(function (e) {\n    e && e.length > 0 && (r = Bt(n = e, i), function (e, t) {\n      var n,\n        r = window.location.href;\n      function o() {\n        (n = window.location.href) !== r && (r = n, t());\n      }\n      !function e(t, n) {\n        t(), setTimeout(function () {\n          e(t, n);\n        }, n);\n      }(o, e), window.history && window.history.pushState ? window.addEventListener(\"popstate\", o) : window.addEventListener(\"hashchange\", o);\n    }(300, o)), t();\n  }).catch(function (n) {\n    e.emitter.maybeReportError(new Rt.LDUnexpectedResponseError((n && n.message, n.message))), t();\n  }), {};\n}\nvar Gt = \"goalsReady\",\n  Xt = {\n    fetchGoals: {\n      default: !0\n    },\n    hash: {\n      type: \"string\"\n    },\n    eventProcessor: {\n      type: \"object\"\n    },\n    eventUrlTransformer: {\n      type: \"function\"\n    },\n    disableSyncEventPost: {\n      default: !1\n    }\n  };\nfunction Qt(e, t) {\n  var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},\n    r = function (e) {\n      var t,\n        n = {\n          userAgentHeaderName: \"X-LaunchDarkly-User-Agent\",\n          synchronousFlush: !1\n        };\n      if (window.XMLHttpRequest) {\n        var r = e && e.disableSyncEventPost;\n        n.httpRequest = function (e, t, o, i) {\n          var a = n.synchronousFlush & !r;\n          return n.synchronousFlush = !1, Kt(e, t, o, i, a);\n        };\n      }\n      n.httpAllowsPost = function () {\n        return void 0 === t && (t = !!window.XMLHttpRequest && \"withCredentials\" in new window.XMLHttpRequest()), t;\n      }, n.httpFallbackPing = function (e) {\n        new window.Image().src = e;\n      };\n      var o,\n        i = e && e.eventUrlTransformer;\n      n.getCurrentUrl = function () {\n        return i ? i(window.location.href) : window.location.href;\n      }, n.isDoNotTrack = function () {\n        var e;\n        return 1 === (e = window.navigator && void 0 !== window.navigator.doNotTrack ? window.navigator.doNotTrack : window.navigator && void 0 !== window.navigator.msDoNotTrack ? window.navigator.msDoNotTrack : window.doNotTrack) || !0 === e || \"1\" === e || \"yes\" === e;\n      };\n      try {\n        window.localStorage && (n.localStorage = {\n          get: function (e) {\n            return new Promise(function (t) {\n              t(window.localStorage.getItem(e));\n            });\n          },\n          set: function (e, t) {\n            return new Promise(function (n) {\n              window.localStorage.setItem(e, t), n();\n            });\n          },\n          clear: function (e) {\n            return new Promise(function (t) {\n              window.localStorage.removeItem(e), t();\n            });\n          }\n        });\n      } catch (e) {\n        n.localStorage = null;\n      }\n      if (e && e.useReport && \"function\" == typeof window.EventSourcePolyfill && window.EventSourcePolyfill.supportedOptions && window.EventSourcePolyfill.supportedOptions.method ? (n.eventSourceAllowsReport = !0, o = window.EventSourcePolyfill) : (n.eventSourceAllowsReport = !1, o = window.EventSource), window.EventSource) {\n        var a = 3e5;\n        n.eventSourceFactory = function (e, t) {\n          var n = Ht(Ht({}, {\n            heartbeatTimeout: a,\n            silentTimeout: a,\n            skipDefaultHeaders: !0\n          }), t);\n          return new o(e, n);\n        }, n.eventSourceIsActive = function (e) {\n          return e.readyState === window.EventSource.OPEN || e.readyState === window.EventSource.CONNECTING;\n        };\n      }\n      return n.userAgent = \"JSClient\", n.version = \"3.9.0\", n.diagnosticSdkData = {\n        name: \"js-client-sdk\",\n        version: \"3.9.0\"\n      }, n.diagnosticPlatformData = {\n        name: \"JS\"\n      }, n.diagnosticUseCombinedEvent = !0, n;\n    }(n),\n    o = jt(e, t, n, r, Xt),\n    i = o.client,\n    a = o.options,\n    s = o.emitter,\n    c = new Promise(function (e) {\n      var t = s.on(Gt, function () {\n        s.off(Gt, t), e();\n      });\n    });\n  i.waitUntilGoalsReady = function () {\n    return c;\n  }, a.fetchGoals ? Wt(o, function () {\n    return s.emit(Gt);\n  }) : s.emit(Gt), \"complete\" !== document.readyState ? window.addEventListener(\"load\", o.start) : o.start();\n  var u = function () {\n    r.synchronousFlush = !0, i.flush().catch(function () {}), r.synchronousFlush = !1;\n  };\n  return document.addEventListener(\"visibilitychange\", function () {\n    \"hidden\" === document.visibilityState && u();\n  }), window.addEventListener(\"pagehide\", u), i;\n}\nvar Yt = qt,\n  Zt = void 0,\n  en = \"3.9.0\";\nvar tn = {\n  initialize: function (e, t) {\n    var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};\n    return console && console.warn && console.warn(Nt.deprecated(\"default export\", \"named LDClient export\")), Qt(e, t, n);\n  },\n  version: en\n};\nexport { Yt as basicLogger, Zt as createConsoleLogger, tn as default, Qt as initialize, en as version };\n//# sourceMappingURL=ldclient.es.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}